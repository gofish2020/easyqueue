# Golang实现异步队列


在高并发系统中，如果我们同时有大量的请求/任务需要进行处理，由于系统的负载能力有限，一次性同时能够处理的请求/任务是有限的。那么这些任务就需要进行排队，先来的先处理，后来的后处理。如果超过了整个队列能够容纳的请求/任务，那么后续的请求/任务直接拒绝掉（丢弃掉），保证整个业务系统的正常运行。
![](image.png)


举个例子：比如我们要做一个秒杀的项目，有个商品数量只有300个，但是同一时刻，有300w个用户来抢商品。对于系统来说，我们需要这300w个用户同时进入到数据库中抢商品吗？肯定是不现实的，数据库是会承受不了的（呀咩爹）。
因为只有300个商品，理论上我们只需要让300个（不同的）用户进来即可。剩下的299.9700w个用户直接拒绝掉即可。
将这300个用户处理完以后，可能商品还有剩余（比如有人退款了），抢购肯定是一直有人在抢，那么继续再来300个用户，继续抢购剩下的商品，直到商品全部被抢购完。

这里的300只是个比喻，比如你有500个商品，每次让100个用户来抢，每抢完一批，再放100用户进来，直到商品抢完（或抢购到期自动结束）。


我们一般的`http`请求，来300w个请求就会直接处理300w请求，并不能做到让请求阻塞排队，并异步处理的效果。所以，需要设计一个队列，让请求阻塞，并通过异步处理的方式处理`http`请求，这样我们就可以控制同时读写数据库的请求数量，不至于把数据库打崩溃。
![](image-1.png)

上面的这种方案是针对请求是可以丢弃的。如果你做的系统比如微博/论坛类型，有个发帖功能，做了一个活动，发帖有奖金，那么可能会有300w个人同时在线发帖，那么这些http请求都是有效的请求，一般情况下我们是不能丢弃的。在高并发系统中，我们可以做限流，比如用户5s内只能发1篇帖子。但是对个人限流完以后，可能还会存在200w的有效请求，此时我们可以这么做。也是通过异步的方式，好处在于帖子后续我们可能还需要做调用审核（第三方的审核可能会很慢）
![](image-2.png)



**ab压测命令：**

`ab -c 10000 -n 30000 http://127.0.0.1:8080/ping` 